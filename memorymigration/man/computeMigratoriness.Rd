% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions_indices.R
\name{computeMigratoriness}
\alias{computeMigratoriness}
\title{Compute Migratoriness}
\usage{
computeMigratoriness(pop, world)
}
\arguments{
\item{pop}{One cycle of population process}

\item{world}{world object; list of 7: a population distribution across the time period in a T x X matrix,
a vector with midpoint X-values, the time points for the population as integers 1:tau, the minimum value of population distribution
(X.min), the maximum value of population distribution (X.max),
the dx value and the tau value. Can incorporate resource attribute into the world to make a list of 8.
Set up by the getSinePop/getOptimal function.}
}
\value{
a list with the time of the minimal overlap and the Migratoriness 
(MI) index
}
\description{
Returns an migratoriness index of a population by comparing the overlap 
overlap of the population from two different times within the year, 
choosing those times to minimize the overlap, and reporting the 
overall overlap.
}
\examples{
# Initialize world
require(memorymigration)
dx <- 1


world <- getOptimalPop(tau = 100, t.peak = 25, 
                               x1 = 40, x2 = -40, x.sd = 5, t.sd = 12)
par0 <- getCCpars(mu_x0 = 40, 
                  mu_t0 = 25,
                  beta_x = 2,
                  beta_t = 0,
                  n.years = 12,
                  sigma_x = 5,
                  sigma_t = 12,
                  psi_x = 0, 
                  psi_t = 0) 
world$resource <- aaply(par0, 1, function(p) getResource_island(world, p))

#run simulation for 12 years 

parameters <- c(epsilon = 5, alpha = 100, beta=50, kappa = 1, lambda = 20)

sim <- runManyYears(world, parameters = parameters, n.years = 5, threshold = 0.9999)

#simulation runs for 3 years since that is when threshold is hit so only 3 years are plotted
plotManyRuns(sim, world)
plotYearList(sim, world, tau = tau)

# computing indices
computeCohesiveness(sim[[3]], world)["SC.mean"]
computeMigratoriness(sim[[3]], world)$overlap
computeEfficiency(sim[[3]], world$resource[3,,], world)
computeAvgEfficiency(sim, world$resource, world)
computeIndices(sim[[3]], world$resource[2,,], world)
}
\seealso{
\link{computeEfficiency}, \link{computeCohesiveness}, \link{computeIndices}
}
